Project 1: Multithreaded Programming with POSIX 

In this project, you need to fix some broken multithreaded code. 
The code uses the POSIX API for threads that we learn about in class. 
So, if you have a Mac, you are in luck! If not, the VM that I made available will work, as will any Linux machine. 
The VM with is available at this link, will work on VirtualBox, and will provide a clean and up-to-date install of Ubuntu. T
he username is student and password is cisco123.  


Your task for this project is to fix the code in this zip file.
 The code is distributed in two files: bst.c and pingpong.c.
  You can build these with the following commands: 


gcc -lpthread bst.c -o bst 

gcc -lpthread pingpong.c -o pingpong 

Running the programs is then as easy as ./bst and ./pingpong, respectively. 


Your first task is to fix the bst.c implementation of bulk insert to a Binary Search Tree. 
This file defines a binary search tree structure, struct bst_node, and functions that operate on those structures, e.g. bst_insert. 
Your task is to correct the implementation of the parallel_insert_worker function. Currently, when a bulk insert occurs (bst_bulk_insert), 
a number of threads are created and all use the tree variable at the same time, stepping over each other. 
You must add locking such that the program finishes its tests successfully every single time. 
One caveat is that multiple threads must be inserting at the same time to gain the performance improvement your manager seeks.
 So simply grabbing a global lock once per inserted element will not be sufficient! 


Your second task is to fix the pingpong.c implementation of alternating thread execution. 
This program is much smaller and currently outputs both “ping\n” and “pong\n” 10000 times, each from their own thread. 
Your task is to cause these to perfectly alternate their output, such that the program outputs “ping\npong\n” 10000 times. 
Your manager had someone else craft a solution, but it used far too much CPU and took quite a long time. 
There are two ways to do this: the naïve way your predecessor alternated threads and the way you have to alternate threads. 
Your solution should use a pthread_cond_t and a pthread_mutex_t, in order to preserve CPU  

 